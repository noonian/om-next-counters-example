["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$om.next.impl.parser","~:imports",null,"~:requires",["^ ","~$set","~$clojure.set","^<","^<","~$util","~$om.util","^>","^>"],"~:uses",null,"~:defs",["^ ","~$expr->ast",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","~:line",115,"~:column",7,"~:end-line",115,"~:end-column",16,"~:arglists",["~#list",["~$quote",["^J",[["~$x"]]]]],"~:doc","Given a query expression convert it into an AST."],"^7","~$om.next.impl.parser/expr->ast","~:variadic",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",16,"~:method-params",["^J",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^J",[null,null]],"^F",1,"^E",115,"^G",115,"~:max-fixed-arity",1,"~:fn-var",true,"^I",["^J",["^K",["^J",[["~$x"]]]]],"^L","Given a query expression convert it into an AST."],"~$call->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",74,"^F",7,"^G",74,"^H",16,"^I",["^J",["^K",["^J",[[["~$f","~$args","~:as","~$call"]]]]]]],"^7","~$om.next.impl.parser/call->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",16,"^O",["^J",[["~$p__9586"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",74,"^G",74,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["~$f","^U","^V","^W"]]]]]]],"~$ast->expr",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",135,"^F",7,"^G",135,"^H",16,"^I",["^J",["^K",["^J",[["~$ast"],[["^ ","~:keys",["~$type","~$component"],"^V","^["],"~$unparse?"]]]]],"^L","Given a query expression AST convert it back into a query expression.","~:top-fn",["^ ","^N",false,"^R",2,"^O",["^J",[["^["],[["^ ","^10",["^11","^12"],"^V","^["],"^13"]]],"^I",["^J",[["^["],[["^ ","^10",["^11","^12"],"^V","^["],"^13"]]],"^Q",["^J",[null,null]]]],"^7","~$om.next.impl.parser/ast->expr","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",16,"^14",["^ ","^N",false,"^R",2,"^O",["^J",[["^["],[["^ ","^10",["^11","^12"],"^V","^["],"^13"]]],"^I",["^J",[["^["],[["^ ","^10",["^11","^12"],"^V","^["],"^13"]]],"^Q",["^J",[null,null]]],"^O",["^J",[["^["],[["^ ","^10",["^11","^12"],"^V","^["],"^13"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",135,"^G",135,"^R",2,"^S",true,"^I",["^J",[["^["],[["^ ","^10",["^11","^12"],"^V","^["],"^13"]]],"^L","Given a query expression AST convert it back into a query expression."],"~$rethrow?",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",237,"^F",7,"^G",237,"^H",15,"^I",["^J",["^K",["^J",[["~$x"]]]]]],"^7","~$om.next.impl.parser/rethrow?","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",15,"^O",["^J",[["~$x"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",237,"^G",237,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$x"]]]]]],"~$path-meta",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",167,"^F",7,"^G",167,"^H",16,"^I",["^J",["^K",["^J",[["~$data","~$path","~$query"],["^19","^1:","^1;","~$union-expr"]]]]],"^L","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union.","^14",["^ ","^N",false,"^R",4,"^O",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^I",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^Q",["^J",[null,null]]]],"^7","~$om.next.impl.parser/path-meta","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",16,"^14",["^ ","^N",false,"^R",4,"^O",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^I",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^Q",["^J",[null,null]]],"^O",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",167,"^G",167,"^R",4,"^S",true,"^I",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^L","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union."],"~$wrap-expr",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",128,"^F",7,"^G",128,"^H",16,"^I",["^J",["^K",["^J",[["~$root?","~$expr"]]]]]],"^7","~$om.next.impl.parser/wrap-expr","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",16,"^O",["^J",[["^1?","^1@"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",128,"^G",128,"^R",2,"^S",true,"^I",["^J",["^K",["^J",[["^1?","^1@"]]]]]],"~$join->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",91,"^F",7,"^G",91,"^H",16,"^I",["^J",["^K",["^J",[["~$join"]]]]]],"^7","~$om.next.impl.parser/join->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",16,"^O",["^J",[["^1C"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",91,"^G",91,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["^1C"]]]]]],"~$keyword->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",54,"^F",7,"^G",54,"^H",19,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"^7","~$om.next.impl.parser/keyword->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",19,"^O",["^J",[["~$k"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",54,"^G",54,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"~$query->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",81,"^F",7,"^G",81,"^H",17,"^I",["^J",["^K",["^J",[["^1;"]]]]],"^L","Convert a query to its AST representation."],"^7","~$om.next.impl.parser/query->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",17,"^O",["^J",[["^1;"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",81,"^G",81,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["^1;"]]]]],"^L","Convert a query to its AST representation."],"~$ident->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",110,"^F",7,"^G",110,"^H",17,"^I",["^J",["^K",["^J",[[["~$k","~$id","^V","~$ref"]]]]]]],"^7","~$om.next.impl.parser/ident->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",17,"^O",["^J",[["~$p__9594"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",110,"^G",110,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["~$k","^1J","^V","^1K"]]]]]]],"~$dispatch",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",299,"^F",7,"^G",299,"^H",15,"^I",["^J",["^K",["^J",[["~$_","~$k","~$_"]]]]]],"^7","~$om.next.impl.parser/dispatch","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",15,"^O",["^J",[["~$_","~$k","~$_"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",299,"^G",299,"^R",3,"^S",true,"^I",["^J",["^K",["^J",[["~$_","~$k","~$_"]]]]]],"~$union-entry->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",59,"^F",7,"^G",59,"^H",23,"^I",["^J",["^K",["^J",[[["~$k","~$v"]]]]]]],"^7","~$om.next.impl.parser/union-entry->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",23,"^O",["^J",[["~$p__9582"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",59,"^G",59,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["~$k","~$v"]]]]]]],"~$parser",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",241,"^F",7,"^G",241,"^H",13,"^I",["^J",["^K",["^J",[[["^ ","^10",["~$read","~$mutate"],"^V","~$config"]]]]]],"^L","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"^7","~$om.next.impl.parser/parser","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",13,"^O",["^J",[["~$p__9637"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",241,"^G",241,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["^ ","^10",["^1T","^1U"],"^V","^1V"]]]]]],"^L","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"~$symbol->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",50,"^F",7,"^G",50,"^H",18,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"^7","~$om.next.impl.parser/symbol->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",18,"^O",["^J",[["~$k"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",50,"^G",50,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"~$union->ast",["^ ","^B",null,"^C",["^ ","^D","/Users/jed/git/projects/om-next-counters-example/resources/public/js/compiled/out/om/next/impl/parser.cljc","^E",69,"^F",7,"^G",69,"^H",17,"^I",["^J",["^K",["^J",[["~$m"]]]]]],"^7","~$om.next.impl.parser/union->ast","^N",false,"^D","resources/public/js/compiled/out/om/next/impl/parser.cljc","^H",17,"^O",["^J",[["~$m"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",69,"^G",69,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$m"]]]]]]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:query-root","~:path","~:remote","~:children","~:union-key","~:read","~:key","~:union-entry","~:else","~:call","~$*","~:value","~:params","~:ast","~:type","~:component","~:error/invalid-join","~:error/invalid-expression","~:om.next/abort","~:parser","~:root","~:result","~:prop","~:dispatch-key","~:om-path","~:action","~:target","^K","~:query","~:om.next/error","~:union","~$...","~:mutate","~:om.next/root","~:join","~:elide-paths"]],"~:order",["^2J","^2:","^2A","^2I","^2B","^28","^2N","^27","^2;","^2P","^K","^2M","^26","^2?","^2=","^2G","^24","^2T","^2Q","^2<","^2C","^2D","^2K","~$*","^2E","^29","^2R","^2U","^2F","^2S","^25","^2@","^2>","^2L","^2H","^2O"]],"^L","\n   Generic query expression parsing and AST manipulation.\n\n   QUERY EXPRESSIONS\n\n   Query expressions are a variation on Datomic Pull Syntax\n   http://docs.datomic.com/pull.html more suitable for generic client/server\n   state transfer. It's important to note the Om Next query expression syntax is\n   *not* a strict superset of Datomic Pull.\n\n   A query expression is composed of EDN values. The grammar for query\n   expressions follows:\n\n   QueryRoot      := EdnVector(QueryExpr*)\n   PlainQueryExpr := (EdnKeyword | IdentExpr | JoinExpr)\n   QueryExpr      := (PlainQueryExpr | ParamExpr)\n   IdentExpr      := EdnVector2(Keyword, EdnValue)\n   ParamExpr      := EdnList2(PlainQueryExpr | EdnSymbol, ParamMapExpr)\n   ParamMapExpr   := EdnMap(Keyword, EdnValue)\n   JoinExpr       := EdnMap((Keyword | IdentExpr), (QueryRoot | UnionExpr | RecurExpr))\n   UnionExpr      := EdnMap(Keyword, QueryRoot)\n   RecurExpr      := ('... | Integer)\n\n   Note most apis in Om Next expect a QueryRoot not a QueryExpr.\n\n   QUERY EXPRESSION AST FORMAT\n\n   Given a QueryExpr you can get the AST via om.next.impl.parser/expr->ast.\n   The following keys can appear in the AST representation:\n\n   {:type         (:prop | :join | :call | :root | :union | :union-entry)\n    :key          (EdnKeyword | EdnSymbol | IdentExpr)\n    :dispatch-key (EdnKeyword | EdnSymbol)\n    :union-key    EdnKeyword\n    :query        (QueryRoot | RecurExpr)\n    :params       ParamMapExpr\n    :children     EdnVector(AST)\n    :component    Object\n    :target       EdnKeyword}\n\n   :query and :params may or may not appear. :type :call is only for\n   mutations."]